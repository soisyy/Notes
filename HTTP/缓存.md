# 浏览器缓存

### 缓存的类型

1. 强缓存: 不需要发送HTTP请求

2. 协商缓存: 需要发送HTTP请求

---

### 强缓存

浏览器通过Expires（HTTP/1.0）和Cache-Control（HTTP/1.1）两个字段来检查强缓存.

Expires: 一个具体的过期时间, 举个🌰

```Expires: Tue, Mar 16 2021 08:00:00 GMT>```

表示这个资源在2021年3月16日08:00:00过期, 在这个时间之后需要重新向服务器请求资源.这种方式看起来清晰明了, 但是如果浏览器时间和服务器时间不一致, 那么就可能造成缓存失效, 所以设置了Expires这种方式并不十分准确, 所以HTTP/1.1采用了Cache-Control这种方式.Cache-Control是通过设置一个过期时长来判断资源是否失效.

```Cache-Control: max-age=100```

即这个资源在100秒之后过期.

Cache-Control除了max-age还有其他一些属性:
**public** : 客户端和代理服务器都可以缓存.
**private** : Cache-Control默认值只有客户端可以缓存.
**no-cache** : 不进行强缓存验证.
**no-store** : 所有内容都不会被缓存, 不进行强缓存, 也不进行协商缓存.
**s-max-age** : max-age用于普通缓存, s-max-age用于代理缓存, 优先级更高.
**max-stale** : 可接受的最大过期时间.
**min-fresh** : 可接受的最小新鲜度.

以上, Expires和Cache-Control的区别:

- Expires用于HTTP/1.0, Cache-Control产于HTTP/1.1时期
- Expires设置一个具体的过期时间, Cache-Control可以设置资源有效时长以及一些属性；
- 两者同时存在是, Cache-Control优先级更高
- Expires不支持HTTP/1.1环境下使用, 可以用来做一些兼容处理

---

### 协商缓存

不需要发送http请求, 强缓存失效就会进入协商缓存.
浏览器会携带缓存标识(tag)向服务器发送请求, 服务器会根据缓存标识(tag)来决定是否使用缓存.

服务器的两种返回:

- 协商缓存生效, 返回304和Not Modified(空的响应体)
- 协商缓存失效, 返回200和请求结果

缓存标识: Last-Modified(资源最后修改时间)和 ETag.

#### Last-Modified

1. 浏览器第一次向服务器请求这个资源
2. 服务器在返回这个资源的时候, 在`response header`中添加`Last-Modified`, 值为该资源在服务器上最后的修改时间
3. 浏览器接收到后缓存文件和这个header
4. 当下次浏览器再次请求这个资源的时候,  检测到有`Last-Modified`这个header, 就会在请求头中添加`If-Modified-Since`, 该值就是`Last-Modified`
5. 服务器再次接收到该资源的请求, 则根据`If-Modified-Since`与服务器中的这个资源的最后修改时间做对比
6. 对比结果相同则返回`304`和一个空的响应体, 告诉浏览器从自己(浏览器)的缓存中拿
7. 对比结果不同(`If-Modified-Since` < 服务器资源最后修改时间), 则表示资源被修改了, 则返回`200`, 最新的资源文件和最新的`Last-Modefied`

#### ETag 与 If-None-Match

1. 在浏览器请求服务器资源的时候, 服务器会根据当前文件的内容, 给文件生成一个唯一的标识, 若是文件发生了改变, 则这个标识就会改变.
2. 服务器会将这个标识`ETag`放到响应体的`header`中与请求的资源一起返回给浏览器, 而浏览器同样也会缓存文件与这个`header`.
3. 下一次再次加载该资源时, 浏览器会将刚刚缓存的`ETag`放到请求体头部(request header)的`If-None-Match`里发送给服务器.
4. 同样的服务器接收到了之后与该资源自身的`ETag`做对比, 如果一致, 则表示该资源未发生改变, 则直接返回`304`知会客户端直接使用本地缓存即可. 若是不一致, 则返回`200`, 最新的资源文件和最新的`ETag`

#### 两者对比

Last-Modified:

若是本地打开了缓存文件, 并没有进行修改, 也还是会改变最后修改时间, 导致缓存失败; 由于`Last-Modified`是以秒来计时的, 若是某个文件在一秒内被修改了很多次, 那么这时候的`Last-Modified`并没有体现出修改了.

ETag:

性能上的不足, 只要文件发生改变, `ETag`就会发生改变. `ETag`需要服务器通过算法来计算出一个hash值.

总结, 所以对于两种协商缓存: 准确度上`ETag`更好; 性能上`Last-Modified`更好; 两者都支持的话, `ETag`优先级更高.
